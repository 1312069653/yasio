/* This file is generated by pcode_autog-1.16.10
** Copyright(c) Lake.Deal, ALL RIGHTS RESERVED.
**
** Purpose: contains all protocol message definiations and codec function
**          implementations
**
*/
#include "pcode_autog_client_messages.h"

#include "pcode_autog_client_constants.h"

#include <unordered_map>

#include <functional>

#include "purelib/utils/crypto_wrapper.h"

using namespace messages;

// pcode_autog_create_header implemented by user.
extern obinarystream pcode_autog_begin_encode(uint16_t command_id, uint16_t reserved = 0x6102);

obinarystream MsgHeader::encode(void) const
{
    obinarystream obs;

    /// encode message fields.
    obs.write_i(this->length);
    obs.write_i(this->command_id);
    obs.write_i(this->version);
    obs.write_i(this->reserved);
    obs.write_i(this->reserved2);
    return obs;
}

int MsgHeader::decode(const char* data, int len)
{
    ibinarystream ibs;
    ibs.vassign(data, len);

    ibs.read_i(this->length);
    ibs.read_i(this->command_id);
    ibs.read_i(this->version);
    ibs.read_i(this->reserved);
    ibs.read_i(this->reserved2);
    return ibs.remain();
}

std::string MsgHeader::get_formated_string(void) const
{
    std::stringstream ss;
    ss << "MsgHeader:\n";
    ss << strfmt("length", this->length << '\n', '-');
    ss << strfmt("command_id", this->command_id << '\n', '-');
    ss << strfmt("version", this->version << '\n', '-');
    ss << strfmt("reserved", this->reserved << '\n', '-');
    ss << strfmt("reserved2", this->reserved2 << '\n', '-');
    return ss.str();
}

std::string LoginReq::get_formated_string(void) const
{
    std::stringstream ss;
    ss << "LoginReq:\n";
    ss << strfmt("username", this->username << '\n', '-');
    ss << strfmt("password", this->password << '\n', '-');
    return ss.str();
}

int LoginReq::decodeLua(lua_State* L)
{
    auto top = lua_gettop(L);
    iluastream ibs(L);
    ibs.read_v("username",this->username);
    ibs.read_v("password",this->password);

    auto check = lua_gettop(L);

    assert(top == check);

    return 0;
}

int LoginReq::encodeLua(lua_State* L) const 
{
    auto top = lua_gettop(L);
    oluastream obs(L);
    lua_newtable(L);
    obs.write_v("username",this->username);
    obs.write_v("password",this->password);

    auto check = lua_gettop(L);

    assert(check > top );

    return 0;
}

std::string LoginResp::get_formated_string(void) const
{
    std::stringstream ss;
    ss << "LoginResp:\n";
    ss << strfmt("succeed", (int)this->succeed << '\n', '-');
    ss << strfmt("session", this->session << '\n', '-');
    ss << strfmt("append_info", this->append_info << '\n', '-');
    return ss.str();
}

int LoginResp::decodeLua(lua_State* L)
{
    auto top = lua_gettop(L);
    iluastream ibs(L);
    ibs.read_i("succeed",this->succeed); 
    ibs.read_i("session",this->session); 
    ibs.read_v("append_info",this->append_info);

    auto check = lua_gettop(L);

    assert(top == check);

    return 0;
}

int LoginResp::encodeLua(lua_State* L) const 
{
    auto top = lua_gettop(L);
    oluastream obs(L);
    lua_newtable(L);
    obs.write_i("succeed",this->succeed);
    obs.write_i("session",this->session);
    obs.write_v("append_info",this->append_info);

    auto check = lua_gettop(L);

    assert(check > top );

    return 0;
}

std::string LocalErrorResp::get_formated_string(void) const
{
    std::stringstream ss;
    ss << "LocalErrorResp:\n";
    ss << strfmt("error_code", this->error_code << '\n', '-');
    ss << strfmt("error_msg", this->error_msg << '\n', '-');
    return ss.str();
}

int LocalErrorResp::decodeLua(lua_State* L)
{
    auto top = lua_gettop(L);
    iluastream ibs(L);
    ibs.read_i("error_code",this->error_code); 
    ibs.read_v("error_msg",this->error_msg);

    auto check = lua_gettop(L);

    assert(top == check);

    return 0;
}

int LocalErrorResp::encodeLua(lua_State* L) const 
{
    auto top = lua_gettop(L);
    oluastream obs(L);
    lua_newtable(L);
    obs.write_i("error_code",this->error_code);
    obs.write_v("error_msg",this->error_msg);

    auto check = lua_gettop(L);

    assert(check > top );

    return 0;
}

std::string MsgPeerEndpointReq::get_formated_string(void) const
{
    std::stringstream ss;
    ss << "MsgPeerEndpointReq:\n";
    ss << strfmt("user_id", this->user_id << '\n', '-');
    return ss.str();
}

int MsgPeerEndpointReq::decodeLua(lua_State* L)
{
    auto top = lua_gettop(L);
    iluastream ibs(L);
    ibs.read_i("user_id",this->user_id); 

    auto check = lua_gettop(L);

    assert(top == check);

    return 0;
}

int MsgPeerEndpointReq::encodeLua(lua_State* L) const 
{
    auto top = lua_gettop(L);
    oluastream obs(L);
    lua_newtable(L);
    obs.write_i("user_id",this->user_id);

    auto check = lua_gettop(L);

    assert(check > top );

    return 0;
}

static char s_allocp[16384]; // static alloc memory.
static std::unordered_map<int, std::function<MsgBase*(void)>> s_table_message_ctor;
MsgBase* messages::temp_create_message(int command_id)
{
    auto target = s_table_message_ctor.find(command_id);
    if(target != s_table_message_ctor.end())
        return (target->second)();
    return nullptr;
}

static int internal_message_ctor_table_preinit(void)
{
    s_table_message_ctor[CID_LOGIN_REQ]= []()->MsgBase*{ return new(s_allocp) LoginReq(); };
    s_table_message_ctor[CID_LOGIN_RESP]= []()->MsgBase*{ return new(s_allocp) LoginResp(); };
    s_table_message_ctor[CID_LOCAL_ERROR_INFO]= []()->MsgBase*{ return new(s_allocp) LocalErrorResp(); };
    s_table_message_ctor[CID_MSG_PEER_ENDPOINT_REQ]= []()->MsgBase*{ return new(s_allocp) MsgPeerEndpointReq(); };
    return 0;
}

static const int __TABLE_INIT_PLACE_HOLDER = internal_message_ctor_table_preinit();

